trigger:
- main  

pool:
  name: Default  # Self-hosted agent pool

variables:
  buildConfiguration: 'Release'
  publishDir: '$(Build.ArtifactStagingDirectory)/publish'
  siteName: 'AutoAppDemo'
  physicalPath: 'C:\inetpub\wwwroot\AutoAppDemo'
  appPoolName: 'AutoAppDemo-pool'
  parentSiteName: 'Optimus Apps'
  appPortHttp: 8026
  appPortHttps: 8025

steps:
- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '8.0.x'
    installationPath: $(Agent.ToolsDirectory)/dotnet

- task: DotNetCoreCLI@2
  displayName: 'Restore NuGet packages'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  displayName: 'Build the project'
  inputs:
    command: 'build'
    arguments: '--configuration $(buildConfiguration)'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  displayName: 'Publish the app'
  inputs:
    command: 'publish'
    publishWebProjects: true
    arguments: '--configuration $(buildConfiguration) --output $(publishDir)'

# ZIP the published output
- task: ArchiveFiles@2
  displayName: 'Zip Published Output'
  inputs:
    rootFolderOrFile: '$(publishDir)'
    includeRootFolder: false
    archiveType: 'zip'
    archiveFile: '$(Build.ArtifactStagingDirectory)/AutoAppDemo.zip'
    replaceExistingArchive: true

# Deploy: Create App Pool + App under Optimus App + Extract + Copy

- task: PowerShell@2
  displayName: 'Deploy AutoAppDemo under Optimus App'
  inputs:
    targetType: 'inline'
    script: |
      $siteName = "$(siteName)"
      $physicalPath = "$(physicalPath)"
      $appPoolName = "$(appPoolName)"
      $parentSite = "$(parentSiteName)"
      $zipPath = "$(Build.ArtifactStagingDirectory)\AutoAppDemo.zip"
      $httpPort = $(appPortHttp)
      $httpsPort = $(appPortHttps)

      Import-Module WebAdministration

      Write-Host "Checking if parent site '$parentSite' exists..."
      if (!(Test-Path "IIS:\Sites\$parentSite")) {
          Write-Host "##vso[task.logissue type=error] Parent site '$parentSite' does not exist. Please create it first."
          exit 1
      }

      Write-Host " Ensuring physical path exists at: $physicalPath"
      if (!(Test-Path $physicalPath)) {
          New-Item -ItemType Directory -Path $physicalPath -Force | Out-Null
          Write-Host "Created directory: $physicalPath"
      }

      Write-Host "ðŸ”§ Creating or verifying App Pool '$appPoolName'..."
      if (!(Test-Path "IIS:\AppPools\$appPoolName")) {
          New-WebAppPool -Name $appPoolName
          Write-Host "App Pool created: $appPoolName"
      }

      $appExists = Get-WebApplication -Site $parentSite | Where-Object { $_.Path -eq "/$siteName" }

      if ($appExists) {
          Write-Host " Application '$siteName' already exists under '$parentSite', updating App Pool..."
          Set-ItemProperty "IIS:\Sites\$parentSite\$siteName" -Name applicationPool -Value $appPoolName
      } else {
          Write-Host "âž• Creating new application '$siteName' under '$parentSite'..."
          New-WebApplication -Site $parentSite -Name $siteName -PhysicalPath $physicalPath -ApplicationPool $appPoolName
      }

      Write-Host "Cleaning contents of: $physicalPath"
      Get-ChildItem -Path $physicalPath -Recurse -Force | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue

      Write-Host "Extracting ZIP to: $physicalPath"
      try {
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $physicalPath)

          if ((Get-ChildItem -Path $physicalPath).Count -eq 0) {
              throw "Zip extraction succeeded but no files found in $physicalPath"
          }

          Write-Host "Extraction successful"
      } catch {
          Write-Host "##vso[task.logissue type=error]Zip extraction failed: $_"
          throw
      }

      Write-Host "Setting access permissions for: IIS AppPool\$appPoolName"
      $acl = Get-Acl $physicalPath
      $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS AppPool\$appPoolName", "ReadAndExecute", "ContainerInherit,ObjectInherit", "None", "Allow")
      $acl.SetAccessRule($rule)
      Set-Acl -Path $physicalPath -AclObject $acl

      Write-Host " Deployment completed successfully!"
# Clean up build artifacts to free memory
- task: PowerShell@2
  displayName: 'Clean up build artifacts'
  condition: always() # Run this even if previous steps fail
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Cleaning up build artifacts to free memory..."
      
      # Clean publish directory
      if (Test-Path "$(publishDir)") {
          Remove-Item -Path "$(publishDir)" -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "Cleaned up publish directory"
      }
      
      # Clean ZIP file
      if (Test-Path "$(Build.ArtifactStagingDirectory)/AutoAppDemo.zip") {
          Remove-Item -Path "$(Build.ArtifactStagingDirectory)/AutoAppDemo.zip" -Force -ErrorAction SilentlyContinue
          Write-Host "Cleaned up ZIP file"
      }
      
      # Run garbage collection to free memory
      [System.GC]::Collect()
      Write-Host "Memory cleanup completed"